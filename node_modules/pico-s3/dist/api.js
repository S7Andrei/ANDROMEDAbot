"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getObjectEtag = exports.objectExists = exports.getObjectMetadata = exports.deleteObject = exports.getObject = exports.getObjectDataUrl = exports.getObjectBuffer = exports.getTextFile = exports.getObjectBinary = exports.upload = exports.uploadBuffer = exports.s3Request = exports.getProviderConfig = exports.getCloudUrl = exports.resolvePath = exports.CLOUD_PROVIDERS = exports.FileNotFoundError = void 0;
const axios_1 = __importDefault(require("axios"));
const aws4_1 = __importDefault(require("aws4"));
const db = require('debug')('pico-s3');
const err = require('debug')('pico-s3:error');
const crypto_1 = __importDefault(require("crypto"));
const import_1 = require("@brillout/import");
let _ft = null;
const ft = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!_ft) {
        const x = yield (0, import_1.import_)('file-type');
        _ft = x;
    }
    return _ft;
});
class FileNotFoundError extends Error {
    constructor(message) {
        super(message);
        this.name = "FileNotFoundError";
    }
}
exports.FileNotFoundError = FileNotFoundError;
var CLOUD_PROVIDERS;
(function (CLOUD_PROVIDERS) {
    CLOUD_PROVIDERS["GCP"] = "GCP";
    CLOUD_PROVIDERS["WASABI"] = "WASABI";
    CLOUD_PROVIDERS["AWS"] = "AWS";
    CLOUD_PROVIDERS["CONTABO"] = "CONTABO";
    CLOUD_PROVIDERS["DO"] = "DO";
    CLOUD_PROVIDERS["MINIO"] = "MINIO";
})(CLOUD_PROVIDERS = exports.CLOUD_PROVIDERS || (exports.CLOUD_PROVIDERS = {}));
const resolvePath = (options) => {
    //remove leading and trailing slash from options.directory
    const directory = options.directory ? options.directory.replace(/^\/|\/$/g, "") : "";
    return options.directory ? `${directory}/${options.filename}` : `${options.filename}`;
};
exports.resolvePath = resolvePath;
/**
 * Please submit a new issue if you need another s3 compatible provider.
 */
const PROVIDERS = {
    "GCP": {
        host: ({ bucket }) => `${bucket}.storage.googleapis.com`,
        url: ({ bucket, filename, directory }) => `https://${bucket}.storage.googleapis.com/${(0, exports.resolvePath)({ filename, directory })}`,
        res: ({ bucket, filename, directory }) => `https://storage.googleapis.com/${bucket}/${(0, exports.resolvePath)({ filename, directory })}`
    },
    "AWS": {
        host: ({ bucket }) => `${bucket}.s3.amazonaws.com`,
        url: ({ bucket, filename, directory }) => `https://${bucket}.s3.amazonaws.com/${(0, exports.resolvePath)({ filename, directory })}`,
        res: ({ bucket, filename, directory, region }) => `https://${bucket}.s3.${region}.amazonaws.com/${(0, exports.resolvePath)({ filename, directory })}`
    },
    "WASABI": {
        host: ({ region, bucket }) => `${bucket}.s3.${region}.wasabisys.com`,
        url: ({ region, filename, directory, bucket }) => `https://${bucket}.s3.${region}.wasabisys.com/${(0, exports.resolvePath)({ filename, directory })}`,
        res: ({ bucket, filename, directory, region }) => `https://s3.${region}.wasabisys.com/${bucket}/${(0, exports.resolvePath)({ filename, directory })}`
    },
    "DO": {
        host: ({ region, bucket }) => `${bucket}.${region}.digitaloceanspaces.com`,
        url: ({ bucket, filename, directory, region }) => `https://${bucket}.${region}.digitaloceanspaces.com/${(0, exports.resolvePath)({ filename, directory: `${directory}` })}`,
        res: ({ bucket, filename, directory, region }) => `https://${bucket}.${region}.digitaloceanspaces.com/${(0, exports.resolvePath)({ filename, directory: `${directory}` })}`
    },
    "CONTABO": {
        host: ({ region }) => `${region}.contabostorage.com`,
        url: ({ bucket, filename, directory, region }) => `https://${region}.contabostorage.com/${(0, exports.resolvePath)({ filename, directory: `${bucket}${directory}` })}`,
        res: ({ bucket, filename, directory, region }) => `https://${region}.contabostorage.com/${(0, exports.resolvePath)({ filename, directory: `${bucket}${directory}` })}`
    },
    "MINIO": {
        host: ({ host }) => `${host}`,
        url: ({ bucket, filename, directory, host }) => `${host}/${bucket}/${(0, exports.resolvePath)({ filename, directory: `${directory}` })}`,
        res: ({ bucket, filename, directory, host }) => `${host}/${bucket}/${(0, exports.resolvePath)({ filename, directory: `${directory}` })}`
    }
};
const getCloudUrl = (options) => PROVIDERS[options.provider].res(options);
exports.getCloudUrl = getCloudUrl;
const getProviderConfig = (provider) => PROVIDERS[provider];
exports.getProviderConfig = getProviderConfig;
const s3Request = (options, extendedRequestOptions) => {
    const { provider, accessKeyId, secretAccessKey } = options;
    const region = provider === CLOUD_PROVIDERS.GCP ? 'region' : options.region;
    const _ = PROVIDERS[provider];
    const _host = _.host(options);
    const host = _host.replace("https://", "").replace("http://", "");
    if (!_)
        throw new Error(`Invalid provider ${provider}. Valid providers: ${Object.keys(PROVIDERS)}`);
    const headers = Object.assign({}, (extendedRequestOptions === null || extendedRequestOptions === void 0 ? void 0 : extendedRequestOptions.headers) || {});
    if (_host.includes("https://") && !headers['x-amz-content-sha256']) {
        headers['x-amz-content-sha256'] = 'UNSIGNED-PAYLOAD';
    }
    extendedRequestOptions === null || extendedRequestOptions === void 0 ? true : delete extendedRequestOptions.headers;
    const toSign = Object.assign({ host, url: _.url(options), service: 's3', region,
        headers }, extendedRequestOptions);
    if (provider === CLOUD_PROVIDERS.MINIO)
        toSign['path'] = _.url(options).replace(_host, "");
    return (0, axios_1.default)(aws4_1.default.sign(toSign, {
        accessKeyId,
        secretAccessKey
    }));
};
exports.s3Request = s3Request;
const uploadBuffer = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const { provider, file } = options;
    const _ = PROVIDERS[provider];
    if (!file || file === null)
        throw new Error("File isnull or undefined");
    const path = `/${(0, exports.resolvePath)(options)}`;
    const _ftResult = yield (yield ft()).fileTypeFromBuffer(file);
    const { mime } = _ftResult || {};
    const filebuf = file;
    /**
     * Infer data type from filename
     */
    const headers = Object.assign(Object.assign({ 'Content-Type': mime || "application/octet-stream", 'x-amz-content-sha256': crypto_1.default.createHash('sha256').update(filebuf).digest('hex') || 'UNSIGNED-PAYLOAD' }, (options.headers || {})), (options.public ? {
        'x-amz-acl': 'public-read'
    } : {}));
    try {
        const START = Date.now();
        db(`Uploading ${path} to ${provider}`);
        db(`Using Headers: ${JSON.stringify(headers)}`);
        yield (0, exports.s3Request)(options, {
            method: 'PUT',
            path,
            data: filebuf,
            headers
        });
        const END = Date.now() - START;
        db(`${path} uploaded  to ${provider} in ${END}ms`);
        return _.res(options) || "";
    }
    catch (error) {
        err("UPLOAD ERROR", path, provider, error.message);
        throw error;
    }
});
exports.uploadBuffer = uploadBuffer;
const upload = (options) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, exports.uploadBuffer)(Object.assign(Object.assign({}, options), { file: Buffer.isBuffer(options.file) ? options.file : Buffer.from(options.file.split(',')[1], 'base64') }));
});
exports.upload = upload;
const getObjectBinary = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield (0, exports.getObject)(options, {
        responseType: 'arraybuffer'
    });
    return res.data;
});
exports.getObjectBinary = getObjectBinary;
const getTextFile = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const buff = yield (0, exports.getObjectBuffer)(options);
    return buff.toString();
});
exports.getTextFile = getTextFile;
const getObjectBuffer = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const bin = yield (0, exports.getObjectBinary)(options);
    return Buffer.from(bin, 'binary');
});
exports.getObjectBuffer = getObjectBuffer;
const getObjectDataUrl = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield (0, exports.getObject)(options, {
        responseType: 'arraybuffer'
    });
    const buff = Buffer.from(res.data, 'binary');
    const dUrl = `data:${res.headers['content-type']};base64,${buff.toString('base64')}`;
    return dUrl;
});
exports.getObjectDataUrl = getObjectDataUrl;
const getObject = (options, axiosOverride) => __awaiter(void 0, void 0, void 0, function* () {
    const { provider } = options;
    const path = `/${(0, exports.resolvePath)(options)}`;
    try {
        const START = Date.now();
        db(`Downloading ${path} from ${provider}`);
        const res = yield (0, exports.s3Request)(options, Object.assign({ method: 'GET', path }, (axiosOverride || {})));
        const END = Date.now() - START;
        db(`${path} downloaded from ${provider} in ${END}ms`);
        return res;
    }
    catch (error) {
        err("GET ERROR", path, provider, error.message);
        if ((error === null || error === void 0 ? void 0 : error.response.status) === 404)
            throw new FileNotFoundError(`File ${path} not found in ${provider}`);
        else
            throw error;
    }
});
exports.getObject = getObject;
const deleteObject = (options, axiosOverride) => __awaiter(void 0, void 0, void 0, function* () {
    const { provider } = options;
    const path = `/${(0, exports.resolvePath)(options)}`;
    try {
        const START = Date.now();
        db(`Deleting ${path} from ${provider}`);
        const res = yield (0, exports.s3Request)(options, Object.assign({ method: 'DELETE', path }, (axiosOverride || {})));
        const END = Date.now() - START;
        db(`${path} deleted from ${provider} in ${END}ms`);
        return res.status === 204;
    }
    catch (error) {
        err("GET ERROR", path, provider, error.message);
        if ((error === null || error === void 0 ? void 0 : error.response.status) === 404)
            throw new FileNotFoundError(`File ${path} not found in ${provider}`);
        else
            throw error;
    }
});
exports.deleteObject = deleteObject;
const getObjectMetadata = (options, axiosOverride) => __awaiter(void 0, void 0, void 0, function* () {
    const { provider } = options;
    const path = `/${(0, exports.resolvePath)(options)}`;
    try {
        const START = Date.now();
        db(`Getting Metadata for ${path} from ${provider}`);
        const res = yield (0, exports.s3Request)(options, Object.assign({ method: 'HEAD', path }, (axiosOverride || {})));
        const END = Date.now() - START;
        db(`${path} metadata downloaded from ${provider} in ${END}ms`);
        return res.headers;
    }
    catch (error) {
        err("GET ERROR", path, provider, error.message);
        if ((error === null || error === void 0 ? void 0 : error.response.status) === 404)
            throw new FileNotFoundError(`File ${path} not found in ${provider}`);
        else
            throw error;
    }
});
exports.getObjectMetadata = getObjectMetadata;
const objectExists = (options, axiosOverride) => __awaiter(void 0, void 0, void 0, function* () { return (0, exports.getObjectMetadata)(options, axiosOverride).then(res => !!res.etag); });
exports.objectExists = objectExists;
const getObjectEtag = (options, axiosOverride) => __awaiter(void 0, void 0, void 0, function* () { return (0, exports.getObjectMetadata)(options, axiosOverride).then(res => res.etag); });
exports.getObjectEtag = getObjectEtag;
